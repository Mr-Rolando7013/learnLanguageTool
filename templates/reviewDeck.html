<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Review Session</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            font-family: Arial, sans-serif;
            background: #2f3b47; /* deep charcoal */
            color: #ecf0f1; /* light gray text for contrast */
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
        }

        .review-container {
            width: 100%;
            max-width: 600px;
            background: #34495e; /* slightly lighter grayish-blue */
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .word-review {
            display: none;
        }

        .word-review.active {
            display: block;
        }

        .step {
            display: none;
        }

        .step.active {
            display: block;
        }

        h2 {
            margin-top: 0;
            color: #e74c3c; /* bold coral for headings */
        }

        .prompt {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #bdc3c7; /* soft light gray for prompts */
        }

        input, textarea {
            width: 100%;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid #7f8c8d; /* muted gray border */
            margin-bottom: 1rem;
            font-size: 1rem;
            background: #2c3e50; /* match dark theme */
            color: #ecf0f1; /* light text on inputs */
        }

        input::placeholder, textarea::placeholder {
            color: #95a5a6; /* light gray placeholder */
        }

        button {
            background: #e74c3c; /* coral */
            color: #fff;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }

        button:hover {
            background: #c0392b; /* darker coral for hover */
        }

        .progress {
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #bdc3c7; /* soft light gray */
        }

        .center {
            text-align: center;
        }

        .word-card {
            display: none;
        }

        .word-card.active {
            display: block;
        }

        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
        }

        .chunk-review {
            display: none;
        }

        .chunk-review.active {
            display: block;
        }
    </style>
</head>
<body>

<div class="review-container">

{% for chunk in chunks %}
{% set word_index = loop.index0 %}
<div class="chunk-review {% if loop.first %}active{% endif %}">
    <!-- Progress -->
    <div class="progress">
        Card <span class="currentStep">1</span> / <span class="totalSteps">{{ chunk|length }}</span>
    </div>

    <!-- TRANSLATION STEP -->
    <div class="step translation-step {% if loop.first %}active{% endif %}">
        {% for word in chunk %}
        <div class="word-card {% if loop.first %}active{% endif %}" data-word-id="{{ word.id }}">
            <h3>{{ word.word }}</h3>
            <div class="prompt">Translate:</div>
            <input data-step="translation" data-type="translation" data-question="Translate {{ word.word }}" />

            {% if word.sentence1 %}
            <div class="prompt"><strong>{{ word.sentence1 }}</strong></div>
            <input data-step="sentence1" data-type="sentence" data-question="{{ word.sentence1 }}" />
            {% endif %}

            {% if word.sentence2 %}
            <div class="prompt"><strong>{{ word.sentence2 }}</strong></div>
            <input data-step="sentence2" data-type="sentence" data-question="{{ word.sentence2 }}" />
            {% endif %}

            {% if word.sentence3 %}
            <div class="prompt"><strong>{{ word.sentence3 }}</strong></div>
            <input data-step="sentence3" data-type="sentence" data-question="{{ word.sentence3 }}" />
            {% endif %}
        </div>
        {% endfor %}

        <div class="center">
            <button onclick="prevWord(this)">Previous</button>
            <button onclick="nextWord(this)">Next</button>
        </div>
    </div>


    <!-- MCQ Exercise 1 -->
    <div class="step mcq-step" data-mcq="1">
        <h2>Multiple Choice</h2>

        {% for word in chunk %}
            {% for mcq in word.mcq %}
            <div class="mcq" data-word-id="{{ word.id }}">
                <strong>{{ mcq.question }}</strong>

                {% for opt in [mcq.option1, mcq.option2, mcq.option3, mcq.option4] %}
                <label>
                    <input type="radio"
                        name="mcq1-{{ word.id }}-{{ mcq.id }}"
                        data-step="mcq1"
                        data-type="mcq"
                        data-question="{{ mcq.question }}"
                        value="{{ opt }}">
                    {{ opt }}
                </label><br>
                {% endfor %}
            </div>
            {% endfor %}
        {% endfor %}

        <button onclick="prevStep(this)">Previous</button>
        <button onclick="nextStep(this)">Next</button>
        </div>

    <div class="step cloze-step" data-cloze="1">
    <h2>Cloze Exercises</h2>

    {% for word in chunk %}
        {% for cloze in word.cloze %}
        <div class="cloze" data-word-id="{{ word.id }}">
            <div class="prompt">
            {{ cloze.sentence }}
            </div>

            <input type="text"
                data-step="cloze-{{ cloze.id }}"
                data-type="cloze"
                data-question="{{ cloze.sentence }}"
                data-exercise-id="{{ cloze.id }}"
                placeholder="Missing wordâ€¦" />
        </div>
        {% endfor %}
    {% endfor %}

    <button onclick="prevStep(this)">Previous</button>
    <button onclick="nextStep(this)">Next</button>
    </div>

    <!-- STEP 4 -->
    <div class="step writing-step">
    <h2>Writing</h2>

    {% for word in chunk %}
        {% for writing in word.writing %}
        <div class="writing" data-word-id="{{ word.id }}">
            <div class="prompt">
            {{ writing.prompt }}
            </div>

            <textarea rows="3"
                    data-step="writing"
                    data-type="writing"
                    data-question="{{ writing.prompt }}"
                    data-exercise-id="{{ writing.id }}"
                    placeholder="Write your sentence hereâ€¦"></textarea>
        </div>
        {% endfor %}
    {% endfor %}

    <button onclick="prevStep(this)">Previous</button>
    <button onclick="finishChunk(this)">Finish</button>
    </div>

    <div class="step results-step">
        <h2>Chunk Results</h2>

        <div class="results-list"></div>

        <div class="center">
            <button onclick="nextChunk(this)">Continue</button>
        </div>
    </div>

</div>
{% endfor %}

</div>

<script>

function nextWord(btn) {
  const step = btn.closest(".step");
  const cards = [...step.querySelectorAll(".word-card")];
  const active = step.querySelector(".word-card.active");
  const idx = cards.indexOf(active);
  if (idx === -1) return;

  active.classList.remove("active");

  if (cards[idx + 1]) {
    cards[idx + 1].classList.add("active");
  } else {
    // Move to next step in this chunk
    step.classList.remove("active");
    const chunk = btn.closest(".chunk-review");
    const steps = [...chunk.querySelectorAll(".step")];
    const stepIdx = steps.indexOf(step);
    if (steps[stepIdx + 1]) steps[stepIdx + 1].classList.add("active");
  }
}

function prevWord(btn) {
  const step = btn.closest(".step");
  const cards = [...step.querySelectorAll(".word-card")];
  const active = step.querySelector(".word-card.active");
  const idx = cards.indexOf(active);

  if (idx === -1) return;

  active.classList.remove("active");

  if (cards[idx - 1]) {
    cards[idx - 1].classList.add("active");
  } else {
    // go back to previous step (if any)
    const chunk = btn.closest(".chunk-review");
    const steps = [...chunk.querySelectorAll(".step")];
    const stepIdx = steps.indexOf(step);

    if (stepIdx > 0) {
      step.classList.remove("active");
      const prevStepEl = steps[stepIdx - 1];
      prevStepEl.classList.add("active");

      // activate last word card in that step (if translation)
      if (prevStepEl.classList.contains("translation-step")) {
        const prevCards = [...prevStepEl.querySelectorAll(".word-card")];
        prevCards.forEach(c => c.classList.remove("active"));
        prevCards.at(-1)?.classList.add("active");
      }
    }
  }
}

function prevStep(btn) {
  const step = btn.closest(".step");
  const chunk = btn.closest(".chunk-review");
  const steps = [...chunk.querySelectorAll(".step")];
  const idx = steps.indexOf(step);

  if (idx <= 0) return; // already at first step

  step.classList.remove("active");
  steps[idx - 1].classList.add("active");

  // if previous step is translation-step, activate last word-card
  const prevStepEl = steps[idx - 1];
  if (prevStepEl.classList.contains("translation-step")) {
    const cards = [...prevStepEl.querySelectorAll(".word-card")];
    cards.forEach(c => c.classList.remove("active"));
    if (cards.length) cards[cards.length - 1].classList.add("active");
  }
}

function nextStep(btn) {
  const step = btn.closest(".step");
  const chunk = btn.closest(".chunk-review");
  const steps = [...chunk.querySelectorAll(".step")];

  const idx = steps.indexOf(step);
  if (idx === -1 || !steps[idx + 1]) return;

  step.classList.remove("active");
  steps[idx + 1].classList.add("active");
}

async function finishChunk(btn) {
  const chunk = btn.closest(".chunk-review");
  const responses = [];

  chunk.querySelectorAll("input, textarea").forEach(input => {
    if (!input.value?.trim()) return;
    if (!input.value?.trim()) return;

    const wordBlock = input.closest("[data-word-id]");
    if (!wordBlock) return;

    responses.push({
      word_id: wordBlock.dataset.wordId,
      step: input.dataset.step,
      type: input.dataset.type,
      exercise_id: input.dataset.exerciseId || null,
      question: input.dataset.question || null,
      answer: input.value?.trim() || ""
    });
  });

  const res = await fetch("/review/submit", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ responses })
  });

  const data = await res.json(); // â† contains scores
  console.log("FinishChunk response:", data.data);
  showChunkResults(chunk, data.data);
}

function showChunkResults(chunk, results) {
  const steps = [...chunk.querySelectorAll(".step")];
  steps.forEach(s => s.classList.remove("active"));

  const resultsStep = chunk.querySelector(".results-step");
  const list = resultsStep.querySelector(".results-list");

  list.innerHTML = "";

  if (!results || results.length === 0) {
    list.innerHTML = "<p>No results available.</p>";
  } else {
    results.forEach(r => {
      list.innerHTML += `
        <div class="result-row">
          <strong>${r.word || "Word"}</strong>
          <span>${r.score != null ? r.score + "%" : "N/A"}</span>
        </div>
      `;
    });
  }

  resultsStep.classList.add("active");
}

function nextChunk(btn) {
  const chunk = btn.closest(".chunk-review");
  chunk.classList.remove("active");

  // hide all steps in old chunk
  chunk.querySelectorAll(".step").forEach(s => s.classList.remove("active"));

  const next = chunk.nextElementSibling;
  if (!next) {
    alert("Session complete ðŸŽ‰");
    return;
  }

  next.classList.add("active");
  next.querySelector(".step")?.classList.add("active");
}

document.addEventListener("keydown", function (e) {
  if (e.key !== "Enter") return;

  const el = e.target;

  // Only apply to translation + sentence inputs
  if (
    el.tagName !== "INPUT" ||
    !["translation", "sentence"].includes(el.dataset.type)
  ) {
    return;
  }

  e.preventDefault(); // stop form submit / paragraph behavior

  // Get all translation + sentence inputs in current chunk
  const chunk = el.closest(".chunk-review");
  const inputs = [...chunk.querySelectorAll(
    'input[data-type="translation"], input[data-type="sentence"]'
  )];

  const idx = inputs.indexOf(el);
  if (inputs[idx + 1]) {
    inputs[idx + 1].focus();
  }
});


</script>

</body>
</html>